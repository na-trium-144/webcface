# 8-2. Client Spec

\tableofcontents

WebCFace Client の動作仕様についてです。
各メッセージのデータ型の説明 [8-1. Message](./81_message.md) も参照しながら読んでください。

## 接続

* サーバーのアドレス(デフォルトでは7530ポート)にWebSocketで接続します。
* 接続できたら、まずクライアント側が sync init (80) のメッセージを送信します
* その後サーバー側から 他のクライアント(=member)に関する sync init (80), 各種データ型の entry (20〜) と、最後に sync init end (88) が送られてくることで接続は完了です。

## 切断

* 切断時に送信するべきメッセージは特にありません。そのままWebSocketを切断すればよいです。

## ping

* サーバーから一定時間おきに ping (89) が送られてきたら、クライアントは ping (89) を送り返してください。
* ping値の情報を取得したい場合は、 ping status req (91) を送ってください。
その後一定時間おきに ping status (90) が送られてきます。

## データの送信 (Sync)

* データを送信する場合、同時刻のデータとして送信したいものをすべてまとめて1回のArrayで送ります
* それに加えて、そのArrayの最初に sync (87) を追加してください
* value (0), text (1), image (5), robot_model (6) は名前とデータをそのまま送信します。
* view (9), canvas2d (10), canvas3d (11) は名前と前回からの差分データのみを送ります。
    * これらは複数の要素(component)からなりますが、それぞれの要素に id (文字列) を割り当て、
    idごとに前回のSync時から変化したもののみを送信します。
    * また各要素のデータと別にその要素idの並び順も送ります。これも前回のSync時から変化した場合のみでよいです。
    * id はそのView/Canvas2D/Canvas3D内で要素ごとに一意なutf-8文字列であれば、命名規則は自由です。
* log (8) は前回送信時から追加された行のみを送信します。
    * また他のデータ型と異なりデータ内に時刻の情報も含まれています。

## データの一覧 (Entry)

* サーバーに新しく他の(無名でない)member(クライアント)が接続したとき、そのmemberの情報が sync init (80) としてサーバーから送られてきます。
* また、新しいデータがサーバーに届いたタイミングで、サーバーから各種データのEntryが送られてきます。
    * Entryのメッセージ型はそれぞれのデータ型のkindに20を足したものになっています。
* クライアントが接続したときすでにサーバーに存在していた他のmemberの情報やデータの情報は sync init end (88) の前にまとめて送られてきます。
* クライアントがデータを送信する際にはサーバーにEntryを送る必要はないです。
* 名前が半角ピリオドから始まるデータについては、Entryは送られてきません。
(Reqを送ることでデータを受信することはできます)

## データのリクエスト (req)

* データを受信するには、まず各種データ型のリクエスト (Req) を送る必要があります。
    * Reqのメッセージ型はそれぞれのデータ型のkindに40を足したものになっています。
    * Reqには受信したい相手のmember id, データの名前, リクエストidを指定します。
    * リクエストidは、クライアントがリクエストを区別するために任意に指定する1以上の整数です。
* リクエストを送った直後と、その後そのデータが変更されたときに、サーバーから sync (87) と各種データ (Res) が送られてきます。
    * sync には member id と時刻が含まれており、そのsyncと同時にまとめて送られてきたデータはすべてそのmemberのその時刻のものです。
    * Resのメッセージ型はそれぞれのデータ型のkindに60を足したものになっています。
    * 基本的には送信時のデータ型とほぼ同じ仕様になっていますが、データ名の代わりにリクエストidとサブフィールド名が含まれています。
    * リクエストidはReqで指定したものです。毎回データ名が送られてくる代わりにidを使うことで通信量を削減しています。
    * サブフィールド名はReqで指定したデータ名に追加されるデータ名です。
        * 例えば `foo` という名前のデータをリクエストして、 `foo` の代わりに `foo.bar` という名前のデータがサーバーに存在した場合、 `foo` のリクエストidと サブフィールド名 `bar` とともに `foo.bar` のデータが送られてきます。


## Funcの定義

* クライアントはFuncを定義した場合、 func info (84) を送信することができます。
    * func info は必ずしも送信しなくてもよいです。 (WebUIなどでFuncの一覧に表示されなくなります)
* また逆に他のmemberがFuncを定義したとき、サーバーからクライアントに func info (84) が送られてきます。
* 他のMemberによってFuncが呼び出されたとき、 call (81) が送られてきます。
    * callを受け取ったクライアントは、まず指定された名前のFuncが存在するかどうかをチェックし、 call response (82) として送り返す必要があります。
    * call response でtrueを送った場合、指定された名前のFuncの処理を実行し、完了したときに結果を call result (83) として送信してください。
    * call response でfalseを送った場合は call result を送信する必要はありません

## Funcの呼び出し (Call)

* Funcを呼び出したい場合、 call (81) を送信します。
    * 呼び出したい相手のmember id とFuncの名前に加えて、 caller id を指定します。
    * caller id は実行結果が返ってくるときに判別できるよう、呼び出し側クライアントが任意に決めて良い数値(0以上の整数)です
* callメッセージが相手memberに到達したら、 call response (82) が送られてきます。
    * 相手memberが存在しなかった場合、サーバーによって call response がfalseで送られてきます。
* call response がtrueの場合、呼び出したFuncの処理が完了したあとに結果が call result (83) として送られてきます。
    * 処理中に相手memberが切断した場合には、サーバーが call result を生成して返します。
* call response がfalseの場合 call result は送られてきません。

<div class="section_buttons">

| Previous |     Next |
|:---------|---------:|
| [8-1. Message](81_message.md) | [8-3. Server Spec](83_server_spec.md) |

</div>
