<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WebCFace: 5-4. View</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    DoxygenAwesomeTabs.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript">
  function insertBadge(){
    for(const sp of document.getElementsByClassName('since-c')){
      const ver = sp.textContent || "1.0";
      sp.innerHTML = `<img src="https://img.shields.io/badge/${ver}~-00599c?logo=C%2B%2B" alt="c++ ver${ver}" class="inline">`;
    }
    for(const sp of document.getElementsByClassName('since-js')){
      const ver = sp.textContent || "1.0";
      sp.innerHTML = `<img src="https://img.shields.io/badge/${ver}~-f7df1e?logo=JavaScript&amp;logoColor=black" alt="js ver${ver}" class="inline">`;
    }
    for(const sp of document.getElementsByClassName('since-py')){
      const ver = sp.textContent || "1.0";
      sp.innerHTML = `<img src="https://img.shields.io/badge/${ver}~-3776ab?logo=python&amp;logoColor=white" alt="python ver${ver}" class="inline">`;
    }
  }
</script>
</head>
<body onload="insertBadge();">
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/na-trium-144/webcface" class="github-corner" aria-label="View source on GitHub">
  <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
  </svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="icon.svg"/></td>
  <td id="projectalign">
   <div id="projectname">WebCFace<span id="projectnumber">&#160;2.5.2</span>
   </div>
   <div id="projectbrief">Web-based Communication Framework &amp; Dashboard-like UI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_254__view.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">5-4. View</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md94">送信</a></li>
<li class="level1"><a href="#autotoc_md95">ViewComponent</a><ul><li class="level2"><a href="#autotoc_md96">text</a></li>
<li class="level2"><a href="#autotoc_md97">newLine</a></li>
<li class="level2"><a href="#autotoc_md98">button</a></li>
<li class="level2"><a href="#autotoc_md99">input</a><ul><li class="level3"><a href="#autotoc_md100">InputRef</a></li>
<li class="level3"><a href="#autotoc_md101">onChange</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md102">オプション</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md103">受信</a><ul><li class="level2"><a href="#autotoc_md104">onClick</a></li>
<li class="level2"><a href="#autotoc_md105">onChangeとbind</a></li>
<li class="level2"><a href="#autotoc_md106">id</a></li>
<li class="level2"><a href="#autotoc_md107">時刻</a></li>
<li class="level2"><a href="#autotoc_md108">Entry</a></li>
<li class="level2"><a href="#autotoc_md109">Event</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="autotoc_md93"></a></p>
<dl class="section since"><dt>Since</dt><dd><span class="since-c"></span> <span class="since-js"></span> <span class="since-py"></span> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li>C++ <a class="el" href="classwebcface_1_1View.html" title="Viewの送受信データを表すクラス">webcface::View</a> (<code><a class="el" href="client_2include_2webcface_2view_8h.html">webcface/view.h</a></code>)</li>
<li>C Reference: <a class="el" href="client_2include_2webcface_2c__wcf_2view_8h.html">c_wcf/view.h</a></li>
<li>JavaScript <a href="https://na-trium-144.github.io/webcface-js/classes/View.html">View</a></li>
<li>Python <a href="https://na-trium-144.github.io/webcface-python/webcface.view.html#webcface.view.View">webcface.View</a></li>
</ul>
</dd></dl>
<p>テキストやボタンなどの配置を送受信します。</p>
<h1><a class="anchor" id="autotoc_md94"></a>
送信</h1>
<dl class="section note"><dt>Note</dt><dd>Viewの2回目以降の送信時にはWebCFace内部では前回からの差分のみが送信されるので、通信量が削減されます</dd></dl>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><p class="startli"><b class="tab-title">C++</b> Client::view からViewオブジェクトを作り、 View::add() などで要素を追加し、 最後にView::sync()をしてからClient::sync()をすることで送信されます。</p>
<p class="startli">Viewはstd::ostreamを継承しており、 add() の代わりに v &lt;&lt; 表示する値; というようにもできます。 ostreamに出力可能なものはそのままviewにテキストとして出力できます。 ostreamと同様にフォーマットを指定したり、std::endlで改行もできます。</p>
<p class="startli">例 </p><div class="fragment"><div class="line"><a class="code hl_class" href="classwebcface_1_1View.html">webcface::View</a> v = wcli.<a class="code hl_function" href="structwebcface_1_1Field.html#a1a6e1affea60ef37fbb3118637671da0">view</a>(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line"><span class="comment">// v.init(); // ←オブジェクトvを新規に構築せず繰り返し使いまわす場合は必要</span></div>
<div class="line">v &lt;&lt; <span class="stringliteral">&quot;hello world&quot;</span> &lt;&lt; std::endl; <span class="comment">// v.add(&quot;hello world&quot;).add(&quot;\n&quot;) と等価</span></div>
<div class="line">v &lt;&lt; i &lt;&lt; std::endl; <span class="comment">// i はintの変数とか</span></div>
<div class="line">v &lt;&lt; <a class="code hl_enumvalue" href="namespacewebcface.html#a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18">webcface::button</a>(<span class="stringliteral">&quot;a&quot;</span>, [] { std::cout &lt;&lt; <span class="stringliteral">&quot;hello&quot;</span> &lt;&lt; std::endl; }) &lt;&lt; std::endl;</div>
<div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#a504472014f457652159a49ff8fa1429a">sync</a>(); <span class="comment">// ここまでにvに追加したものをクライアントに反映</span></div>
<div class="line">wcli.<a class="code hl_function" href="classwebcface_1_1View.html#a504472014f457652159a49ff8fa1429a">sync</a>();</div>
<div class="ttc" id="aclasswebcface_1_1View_html"><div class="ttname"><a href="classwebcface_1_1View.html">webcface::View</a></div><div class="ttdoc">Viewの送受信データを表すクラス</div><div class="ttdef"><b>Definition</b> view.h:26</div></div>
<div class="ttc" id="aclasswebcface_1_1View_html_a504472014f457652159a49ff8fa1429a"><div class="ttname"><a href="classwebcface_1_1View.html#a504472014f457652159a49ff8fa1429a">webcface::View::sync</a></div><div class="ttdeci">const View &amp; sync() const</div><div class="ttdoc">Viewの内容をclientに反映し送信可能にする</div><div class="ttdef"><b>Definition</b> view.cc:31</div></div>
<div class="ttc" id="anamespacewebcface_html_a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18"><div class="ttname"><a href="namespacewebcface.html#a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18">webcface::ViewComponentType::button</a></div><div class="ttdeci">@ button</div></div>
<div class="ttc" id="astructwebcface_1_1Field_html_a1a6e1affea60ef37fbb3118637671da0"><div class="ttname"><a href="structwebcface_1_1Field.html#a1a6e1affea60ef37fbb3118637671da0">webcface::Field::view</a></div><div class="ttdeci">View view(std::string_view field=&quot;&quot;) const</div><div class="ttdef"><b>Definition</b> field.cc:74</div></div>
</div><!-- fragment --><p> <img src="https://github.com/na-trium-144/webcface/raw/main/docs/images/example_view.png" alt="example_view.png" class="inline"/></p>
<dl class="section warning"><dt>Warning</dt><dd><span class="since-c">2.0</span> ワイド文字列を出力したい場合はostreamに直接渡すのではなく Component::text を使う必要があります。 (後述)</dd></dl>
<p>C++ではViewのデストラクタでも自動的にView.sync()が呼ばれます。 </p><div class="fragment"><div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classwebcface_1_1View.html">webcface::View</a> v = wcli.<a class="code hl_function" href="structwebcface_1_1Field.html#a1a6e1affea60ef37fbb3118637671da0">view</a>(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">    v &lt;&lt; ...;</div>
<div class="line">    v &lt;&lt; ...;</div>
<div class="line">    <span class="comment">// v.sync(); (自動で呼ばれる)</span></div>
<div class="line">}</div>
<div class="line">wcli.sync();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><span class="since-c">1.2</span> Viewオブジェクトをコピーした場合、Viewオブジェクトの内容はコピーされるのではなく共有され、そのすべてのコピーが破棄されるまでsync()は呼ばれません。</dd></dl>
</li>
<li><p class="startli"><b class="tab-title">C</b> </p><dl class="section since"><dt>Since</dt><dd><span class="since-c">1.7</span></dd></dl>
<p><a class="el" href="structwcfViewComponent.html" title="Viewの要素を表すstruct.">wcfViewComponent</a>, (<span class="since-c">2.0</span> <a class="el" href="structwcfViewComponentW.html" title="Viewの要素を表すstruct (wstring)">wcfViewComponentW</a>) の配列を wcfViewSet, (<span class="since-c">2.0</span> wcfViewSetW) に指定することで送信されます。</p>
<p class="startli">例 </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structwcfViewComponent.html">wcfViewComponent</a> vc[10];</div>
<div class="line">vc[0] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#aa4da60375e4605b9c85fa1ded4d1c479">wcfText</a>(<span class="stringliteral">&quot;hello world\n&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span> buf[10];</div>
<div class="line">sprintf(buf, <span class="stringliteral">&quot;%d&quot;</span>, i); <span class="comment">// i はintの変数とか</span></div>
<div class="line">vc[1] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#aa4da60375e4605b9c85fa1ded4d1c479">wcfText</a>(buf);</div>
<div class="line">vc[2] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#a55711caabc1dd11ce91cfe3d2391ff31">wcfNewLine</a>(); <span class="comment">// wcfText(&quot;\n&quot;) と同じ</span></div>
<div class="line"><a class="code hl_function" href="client_2include_2webcface_2c__wcf_2func_8h.html#a34feb8c3abc607d947e2a433781a51e9">wcfFuncListen</a>(wcli, <span class="stringliteral">&quot;hoge&quot;</span>, ...) <span class="comment">// 関数の登録: 詳細は Func のページを参照</span></div>
<div class="line">vc[3] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#af6ea4ac458a3dfde614db687447f4cd4">wcfButton</a>(&quot;a&quot;, NULL, &quot;hoge&quot;);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#ac4ee7b53b9afcff2d84a138a142ae00d">wcfViewSet</a>(wcli, &quot;a&quot;, vc, 4);</div>
<div class="line"><a class="code hl_function" href="c__wcf_2client_8h.html#ad675449898eb92ab9461d31fe88b4896">wcfSync</a>();</div>
<div class="ttc" id="ac__wcf_2client_8h_html_ad675449898eb92ab9461d31fe88b4896"><div class="ttname"><a href="c__wcf_2client_8h.html#ad675449898eb92ab9461d31fe88b4896">wcfSync</a></div><div class="ttdeci">wcfStatus wcfSync(wcfClient *wcli)</div><div class="ttdoc">送信用にセットしたデータをすべて送信キューに入れ、受信したデータを処理する</div><div class="ttdef"><b>Definition</b> client.cc:72</div></div>
<div class="ttc" id="aclient_2include_2webcface_2c__wcf_2func_8h_html_a34feb8c3abc607d947e2a433781a51e9"><div class="ttname"><a href="client_2include_2webcface_2c__wcf_2func_8h.html#a34feb8c3abc607d947e2a433781a51e9">wcfFuncListen</a></div><div class="ttdeci">wcfStatus wcfFuncListen(wcfClient *wcli, const char *field, const wcfValType *arg_types, int arg_size, wcfValType return_type)</div><div class="ttdoc">関数呼び出しの待受を開始する</div><div class="ttdef"><b>Definition</b> func.cc:314</div></div>
<div class="ttc" id="aclient_2include_2webcface_2c__wcf_2view_8h_html_a55711caabc1dd11ce91cfe3d2391ff31"><div class="ttname"><a href="client_2include_2webcface_2c__wcf_2view_8h.html#a55711caabc1dd11ce91cfe3d2391ff31">wcfNewLine</a></div><div class="ttdeci">wcfViewComponent wcfNewLine(void)</div><div class="ttdef"><b>Definition</b> view.cc:61</div></div>
<div class="ttc" id="aclient_2include_2webcface_2c__wcf_2view_8h_html_aa4da60375e4605b9c85fa1ded4d1c479"><div class="ttname"><a href="client_2include_2webcface_2c__wcf_2view_8h.html#aa4da60375e4605b9c85fa1ded4d1c479">wcfText</a></div><div class="ttdeci">wcfViewComponent wcfText(const char *text)</div><div class="ttdef"><b>Definition</b> view.cc:59</div></div>
<div class="ttc" id="aclient_2include_2webcface_2c__wcf_2view_8h_html_ac4ee7b53b9afcff2d84a138a142ae00d"><div class="ttname"><a href="client_2include_2webcface_2c__wcf_2view_8h.html#ac4ee7b53b9afcff2d84a138a142ae00d">wcfViewSet</a></div><div class="ttdeci">wcfStatus wcfViewSet(wcfClient *wcli, const char *field, const wcfViewComponent *components, int size)</div><div class="ttdoc">Viewを送信する</div><div class="ttdef"><b>Definition</b> view.cc:155</div></div>
<div class="ttc" id="aclient_2include_2webcface_2c__wcf_2view_8h_html_af6ea4ac458a3dfde614db687447f4cd4"><div class="ttname"><a href="client_2include_2webcface_2c__wcf_2view_8h.html#af6ea4ac458a3dfde614db687447f4cd4">wcfButton</a></div><div class="ttdeci">wcfViewComponent wcfButton(const char *text, const char *on_click_member, const char *on_click_field)</div><div class="ttdef"><b>Definition</b> view.cc:63</div></div>
<div class="ttc" id="astructwcfViewComponent_html"><div class="ttname"><a href="structwcfViewComponent.html">wcfViewComponent</a></div><div class="ttdoc">Viewの要素を表すstruct.</div><div class="ttdef"><b>Definition</b> def_types.h:218</div></div>
</div><!-- fragment --><p class="startli"><img src="https://github.com/na-trium-144/webcface/raw/main/docs/images/example_view.png" alt="example_view.png" class="inline"/></p>
</li>
<li><p class="startli"><b class="tab-title">JavaScript</b> Client::view からViewオブジェクトを作り、 set()の引数に要素をまとめてセットして使います。</p>
<p class="startli">例 </p><div class="fragment"><div class="line">wcli.view(&quot;a&quot;).set([</div>
<div class="line">    &quot;hello world\n&quot;,</div>
<div class="line">    i, // i は適当な変数とか</div>
<div class="line">    &quot;\n&quot;,</div>
<div class="line">    viewComponents.button(&quot;a&quot;, () =&gt; console.log(&quot;hello&quot;))</div>
<div class="line">]);</div>
</div><!-- fragment --><p> <img src="https://github.com/na-trium-144/webcface/raw/main/docs/images/example_view.png" alt="example_view.png" class="inline"/></p>
</li>
<li><p class="startli"><b class="tab-title">Python</b> Client.view からViewオブジェクトを作り、 View.add() などで要素を追加し、 最後にView.sync()をしてからClient.sync()をすることで送信されます。</p>
<p class="startli">例 </p><div class="fragment"><div class="line">v = wcli.view(<span class="stringliteral">&quot;a&quot;</span>)</div>
<div class="line"><span class="comment"># v.init() ←オブジェクトvを新規に構築せず繰り返し使いまわす場合は必要</span></div>
<div class="line">v.add(<span class="stringliteral">&quot;hello world\n&quot;</span>)</div>
<div class="line">v.add(i, <span class="stringliteral">&quot;\n&quot;</span>) <span class="comment"># i は適当な変数とか</span></div>
<div class="line">v.add(<a class="code hl_function" href="namespacewebcface_1_1components.html#a88c2cdf079489564311bab9249d5c086">webcface.components.button</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="keyword">lambda</span>: print(<span class="stringliteral">&quot;hello&quot;</span>)))</div>
<div class="line">v.sync()</div>
<div class="ttc" id="anamespacewebcface_1_1components_html_a88c2cdf079489564311bab9249d5c086"><div class="ttname"><a href="namespacewebcface_1_1components.html#a88c2cdf079489564311bab9249d5c086">webcface::components::button</a></div><div class="ttdeci">TemporalViewComponent button(std::string_view text, T &amp;&amp;func)</div><div class="ttdoc">buttonコンポーネント</div><div class="ttdef"><b>Definition</b> components.h:615</div></div>
</div><!-- fragment --><p> add() にはコンマ区切りで複数の要素を渡すこともできます(1つずつadd()するのと同じです)</p>
<p class="startli"><img src="https://github.com/na-trium-144/webcface/raw/main/docs/images/example_view.png" alt="example_view.png" class="inline"/></p>
<p class="startli">with構文を使って <code>with wcli.view("hoge") as v:</code> などとするとwithを抜けるときに自動でv.sync()がされます。 </p><div class="fragment"><div class="line"><span class="keyword">with</span> wcli.view(<span class="stringliteral">&quot;a&quot;</span>) <span class="keyword">as</span> v:</div>
<div class="line">    v.add(...)</div>
<div class="line">    v.add(...)</div>
<div class="line">    <span class="comment"># v.sync() (自動で呼ばれる)</span></div>
</div><!-- fragment --></li>
</ul>
</div><div class="tabbed"></div><h1><a class="anchor" id="autotoc_md95"></a>
ViewComponent</h1>
<p>Viewに追加する各種要素をViewComponentといいます。</p>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><p class="startli"><b class="tab-title">C++</b> <del><code>webcface::ViewComponents</code> </del> <br  />
 <span class="since-c">1.9</span> <del><code>webcface::Components</code></del> <br  />
 <span class="since-c">2.0</span> <code><a class="el" href="namespacewebcface_1_1components.html">webcface::components</a></code> 名前空間に定義されています。</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacewebcface_1_1components.html">webcface::components</a>;</div>
<div class="ttc" id="anamespacewebcface_1_1components_html"><div class="ttname"><a href="namespacewebcface_1_1components.html">webcface::components</a></div><div class="ttdef"><b>Definition</b> components.h:380</div></div>
</div><!-- fragment --><p> をすると便利かもしれません</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>namespace components はinlineなので、 <code>webcface::</code> の名前空間でもアクセス可能です。</li>
<li>また以前のnamespace名もエイリアスになっておりどちらでもokです。</li>
</ul>
</dd></dl>
<p>各要素はそれぞれの関数から <a class="el" href="classwebcface_1_1TemporalViewComponent.html" title="Viewを構築するときに使う一時的なViewComponent.">webcface::TemporalViewComponent</a> または <a class="el" href="structwebcface_1_1TemporalComponent.html" title="Canvas2D, Canvas3D (, View) に要素をaddするときに使うインタフェース">webcface::TemporalComponent</a> のオブジェクトとして得られます。</p>
<p class="startli"><span class="since-c">1.11</span> 引数にView(コピーまたはconst参照)を取る関数オブジェクトをViewに渡すと、その場でその関数が呼び出されます。 複数のViewComponentを出力する処理をまとめて使いまわしたい場合に便利です。 </p><div class="fragment"><div class="line"><span class="keyword">auto</span> showNameAndValue(<span class="keyword">const</span> std::string &amp;name, <span class="keywordtype">int</span> value) {</div>
<div class="line">    <span class="keywordflow">return</span> [=](<span class="keyword">const</span> <a class="code hl_class" href="classwebcface_1_1View.html">webcface::View</a> &amp;view) {</div>
<div class="line">        view &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; value;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classwebcface_1_1View.html">webcface::View</a> v = wcli.<a class="code hl_function" href="structwebcface_1_1Field.html#a1a6e1affea60ef37fbb3118637671da0">view</a>(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">v &lt;&lt; showNameAndValue(<span class="stringliteral">&quot;foo&quot;</span>, 123) &lt;&lt; std::endl; <span class="comment">// v &lt;&lt; &quot;foo = 123&quot;;</span></div>
<div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#a504472014f457652159a49ff8fa1429a">sync</a>();</div>
</div><!-- fragment --></li>
<li><b class="tab-title">JavaScript</b> JavaScriptでは <a href="https://na-trium-144.github.io/webcface-js/variables/viewComponents.html"><code>viewComponents</code></a> オブジェクト内にそれぞれの要素を表す関数があります <div class="fragment"><div class="line">import { viewComponents } from &quot;webcface&quot;;</div>
</div><!-- fragment --></li>
<li><b class="tab-title">Python</b> Pythonでは <del><code>webcface.view_components</code></del> <span class="since-c">3.0</span> <a href="https://na-trium-144.github.io/webcface-python/webcface.components.html"><code>webcface.components</code></a> モジュール内にそれぞれの要素を表す関数があります <div class="fragment"><div class="line"><span class="keyword">from</span> <a class="code hl_namespace" href="namespacewebcface_1_1components.html">webcface.components</a> <span class="keyword">import</span> *</div>
</div><!-- fragment --> とすることもできます</li>
</ul>
</div><div class="tabbed"></div><h2><a class="anchor" id="autotoc_md96"></a>
text</h2>
<p>文字列です。そのまま表示します。</p>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><p class="startli"><b class="tab-title">C++</b> std::ostreamでフォーマット可能なデータはそのまま渡して文字列化できます。 View::add()関数, set()関数でも同様に文字列に変換されます。 </p><div class="fragment"><div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;hello&quot;</span>).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(123);</div>
<div class="line">v &lt;&lt; <span class="stringliteral">&quot;hello&quot;</span> &lt;&lt; 123;</div>
<div class="ttc" id="aclasswebcface_1_1View_html_ad9dd8ab0c2a24cdf120d2f294cebf838"><div class="ttname"><a href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">webcface::View::add</a></div><div class="ttdeci">const View &amp; add(T &amp;&amp;rhs) const</div><div class="ttdoc">コンポーネントなどを追加</div><div class="ttdef"><b>Definition</b> view.h:243</div></div>
</div><!-- fragment --><p class="startli">文字列を直接渡す代わりに <code>text(文字列)</code> でViewComponentに変換すると、textColorなど後述のオプションを指定することもできるようになります。 </p><div class="fragment"><div class="line">v &lt;&lt; <a class="code hl_enumvalue" href="namespacewebcface.html#a18133126518e30ea437441c60fa26928a1cb251ec0d568de6a929b520c4aed8d1">webcface::text</a>(<span class="stringliteral">&quot;hello&quot;</span>).textColor(<a class="code hl_enumvalue" href="namespacewebcface.html#a5dcc1f15d6a60ca34207565aeb74124aabda9643ac6601722a28f238714274da4">webcface::ViewColor::red</a>);</div>
<div class="ttc" id="anamespacewebcface_html_a18133126518e30ea437441c60fa26928a1cb251ec0d568de6a929b520c4aed8d1"><div class="ttname"><a href="namespacewebcface.html#a18133126518e30ea437441c60fa26928a1cb251ec0d568de6a929b520c4aed8d1">webcface::Canvas2DComponentType::text</a></div><div class="ttdeci">@ text</div></div>
<div class="ttc" id="anamespacewebcface_html_a5dcc1f15d6a60ca34207565aeb74124aabda9643ac6601722a28f238714274da4"><div class="ttname"><a href="namespacewebcface.html#a5dcc1f15d6a60ca34207565aeb74124aabda9643ac6601722a28f238714274da4">webcface::ViewColor::red</a></div><div class="ttdeci">@ red</div></div>
</div><!-- fragment --><p class="startli"><span class="since-c">2.0</span> Viewに直接ワイド文字列を出力することはできませんが、text()の引数にはワイド文字列も使用可能です。</p>
</li>
<li><b class="tab-title">C</b> wcfText, (<span class="since-c">2.0</span> wcfTextW) でテキストを指定します。 <div class="fragment"><div class="line">vc[0] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#aa4da60375e4605b9c85fa1ded4d1c479">wcfText</a>(<span class="stringliteral">&quot;hello&quot;</span>);</div>
</div><!-- fragment --></li>
<li><b class="tab-title">JavaScript</b> string, number, boolean は文字列に変換されます。 <div class="fragment"><div class="line">wcli.view(&quot;hoge&quot;).set([</div>
<div class="line">    &quot;hello&quot;,</div>
<div class="line">    123,</div>
<div class="line">]);</div>
</div><!-- fragment --> 文字列を直接渡す代わりに <code>text(文字列)</code> でViewComponentに変換すると、textColorなど後述のオプションを指定することもできるようになります。 <div class="fragment"><div class="line">import { viewComponents, viewColor } from &quot;webcface&quot;;</div>
<div class="line">wcli.view(&quot;hoge&quot;).set([</div>
<div class="line">    viewComponents.text(&quot;hello&quot;, { textColor: viewColor.red }),</div>
<div class="line">    123,</div>
<div class="line">]);</div>
</div><!-- fragment --></li>
<li><p class="startli"><b class="tab-title">Python</b> str, int, float, bool はaddの引数に直接指定すると文字列に変換されます。 </p><div class="fragment"><div class="line">v.add(<span class="stringliteral">&quot;hello&quot;</span>).add(123)</div>
</div><!-- fragment --><p> 文字列を直接渡す代わりに <code>text(文字列)</code> でViewComponentに変換すると、text_colorなど後述のオプションを指定することもできるようになります。 </p><div class="fragment"><div class="line">v.add(components.text(<span class="stringliteral">&quot;hello&quot;</span>, text_color=webcface.ViewColor.RED))</div>
</div><!-- fragment --><p class="startli"><span class="since-c">3.0</span> オプションはadd()の引数としても渡すことができます。 </p><div class="fragment"><div class="line">v.add(<span class="stringliteral">&quot;hello&quot;</span>, text_color=webcface.ViewColor.RED)</div>
</div><!-- fragment --></li>
</ul>
</div><div class="tabbed"></div><h2><a class="anchor" id="autotoc_md97"></a>
newLine</h2>
<p>改行します。</p>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><b class="tab-title">C++</b> <code><a class="el" href="namespacewebcface_1_1components.html#a817906c33da38b85572a194e424b8612" title="newLineコンポーネント">webcface::newLine()</a></code> の他、<code>std::endl</code>や<code>"\n"</code>でも改行できます。 <code>\n</code>は単体でなく文字列中にあってもそこで改行されます。 <div class="fragment"><div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;hello\nhello&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;hello&quot;</span>).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;\n&quot;</span>).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;hello&quot;</span>);</div>
<div class="line">v &lt;&lt; <span class="stringliteral">&quot;hello\nhello&quot;</span>;</div>
<div class="line">v &lt;&lt; <span class="stringliteral">&quot;hello&quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line"><span class="keyword">using namespace </span>webcface::Components;</div>
<div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(text(<span class="stringliteral">&quot;hello&quot;</span>)).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(newLine()).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(text(<span class="stringliteral">&quot;hello&quot;</span>));</div>
<div class="line">v &lt;&lt; text(<span class="stringliteral">&quot;hello&quot;</span>) &lt;&lt; newLine() &lt;&lt; text(<span class="stringliteral">&quot;hello&quot;</span>);</div>
</div><!-- fragment --></li>
<li><p class="startli"><b class="tab-title">C</b> wcfText に<code>\n</code>を渡すか、 wcfNewLine, (<span class="since-c">2.0</span> wcfNewLineW) で指定できます。 wcfTextの文字列の途中に<code>\n</code>がある場合もそこで改行されます </p><div class="fragment"><div class="line">vc[0] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#aa4da60375e4605b9c85fa1ded4d1c479">wcfText</a>(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">vc[0] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#a55711caabc1dd11ce91cfe3d2391ff31">wcfNewLine</a>();</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>newLineには文字列を渡す機能はないですが、他の要素と型を合わせるためにwcfNewLineとwcfNewLineWを使い分ける必要があります</dd></dl>
</li>
<li><b class="tab-title">JavaScript</b> <code>newLine()</code>の他<code>"\n"</code>でも改行できます。 <code>\n</code>は単体でなく文字列中にあってもそこで改行されます。 <div class="fragment"><div class="line">wcli.view(&quot;hoge&quot;).set([</div>
<div class="line">    &quot;hello\nhello&quot;,</div>
<div class="line">    viewComponents.newLine(),</div>
<div class="line">    &quot;hello&quot;,</div>
<div class="line">]);</div>
</div><!-- fragment --></li>
<li><b class="tab-title">Python</b> <code>new_line()</code> の他、<code>"\n"</code>でも改行できます。 <code>\n</code>は単体でなく文字列中にあってもそこで改行されます。 <div class="fragment"><div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;hello\nhello&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;hello&quot;</span>).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;\n&quot;</span>).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(<span class="stringliteral">&quot;hello&quot;</span>);</div>
<div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(text(<span class="stringliteral">&quot;hello&quot;</span>)).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(new_line()).<a class="code hl_function" href="classwebcface_1_1View.html#ad9dd8ab0c2a24cdf120d2f294cebf838">add</a>(text(<span class="stringliteral">&quot;hello&quot;</span>));</div>
</div><!-- fragment --></li>
</ul>
</div><div class="tabbed"></div><h2><a class="anchor" id="autotoc_md98"></a>
button</h2>
<p>ボタンを表示します。</p>
<p>クリック時の動作は、関数を登録済みの<a class="el" href="md_docs_253__func.html">Funcオブジェクト</a>かFuncListenerオブジェクトを指定するか、または関数を直接設定できます。</p>
<dl class="section note"><dt>Note</dt><dd>別のMemberのFuncオブジェクトを渡すこともできます (ボタンを押すと別のMemberに登録されている関数が実行される)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="since-c">2.5</span> <span class="since-py">3.0</span> buttonや、このあと説明するinputなど、インタラクティブな動作を伴う要素には id として一意な文字列を指定してください。 通常は指定しなくても動作しますが、 次の例のようにview内に要素が出現したり消滅したりするようなものを書いた場合 その切り替わりのタイミングで要素の内容がずれる場合があります。 <div class="fragment"><div class="line"><span class="keyword">auto</span> v = wcli.<a class="code hl_function" href="structwebcface_1_1Field.html#a1a6e1affea60ef37fbb3118637671da0">view</a>(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(some_condition){</div>
<div class="line">    <span class="comment">// some_conditionによって表示されたりされなかったりする</span></div>
<div class="line">    v &lt;&lt; <a class="code hl_enumvalue" href="namespacewebcface.html#a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18">webcface::button</a>(...);</div>
<div class="line">}</div>
<div class="line">v &lt;&lt; <a class="code hl_enumvalue" href="namespacewebcface.html#a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18">webcface::button</a>(...);</div>
<div class="line">v.<a class="code hl_function" href="classwebcface_1_1View.html#a504472014f457652159a49ff8fa1429a">sync</a>();</div>
</div><!-- fragment --></dd></dl>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><p class="startli"><b class="tab-title">C++</b> Funcオブジェクト、 <span class="since-c">2.5</span> FuncListerオブジェクト の場合 </p><div class="fragment"><div class="line">wcli.func(<span class="stringliteral">&quot;hoge&quot;</span>).set(<span class="comment">/*...*/</span>);</div>
<div class="line">v &lt;&lt; <a class="code hl_enumvalue" href="namespacewebcface.html#a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18">webcface::button</a>(<span class="stringliteral">&quot;表示する文字列&quot;</span>, wcli.func(<span class="stringliteral">&quot;hoge&quot;</span>)).id(<span class="stringliteral">&quot;button1&quot;</span>);</div>
<div class="line"><span class="comment">// v.add(...) でも同様</span></div>
</div><!-- fragment --><p class="startli">関数を直接渡す場合 (非表示のFuncとして登録され、他のFuncと同様に扱われます。 WebUIや他MemberからはFuncの存在は見えません) </p><div class="fragment"><div class="line">v &lt;&lt; <a class="code hl_enumvalue" href="namespacewebcface.html#a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18">webcface::button</a>(<span class="stringliteral">&quot;表示する文字列&quot;</span>, [](){ <span class="comment">/* ... */</span> }).<span class="keywordtype">id</span>(<span class="stringliteral">&quot;button1&quot;</span>);</div>
</div><!-- fragment --></li>
<li><b class="tab-title">C</b> 関数の登録方法は <a class="el" href="md_docs_253__func.html">Func</a> を参照してください。 表示する文字列に加え登録したFuncのmember名と名前を wcfButton, (<span class="since-c">2.0</span> wcfButtonW) に指定します。 member名をNULLまたは空文字列にすると自分自身が登録した関数を指します。 <div class="fragment"><div class="line">vc[0] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#af6ea4ac458a3dfde614db687447f4cd4">wcfButton</a>(<span class="stringliteral">&quot;表示する文字列&quot;</span>, NULL, <span class="stringliteral">&quot;hoge&quot;</span>);</div>
</div><!-- fragment --></li>
<li><b class="tab-title">JavaScript</b> Funcオブジェクトの場合 <div class="fragment"><div class="line">wcli.func(&quot;hoge&quot;).set(/* ... */);</div>
<div class="line">wcli.view(&quot;hoge&quot;).set([</div>
<div class="line">    viewComponents.button(&quot;表示する文字列&quot;, wcli.func(&quot;hoge&quot;)),</div>
<div class="line">]);</div>
</div><!-- fragment --> 関数を直接渡す場合 (WebUIや他MemberからはFuncの存在は見えません) <div class="fragment"><div class="line">wcli.view(&quot;hoge&quot;).set([</div>
<div class="line">    viewComponents.button(&quot;表示する文字列&quot;, () =&gt; {/* ... */})</div>
<div class="line">]);</div>
</div><!-- fragment --></li>
<li><b class="tab-title">Python</b> Funcオブジェクト、FuncListenerオブジェクトの場合 <div class="fragment"><div class="line">wcli.func(<span class="stringliteral">&quot;hoge&quot;</span>).set(...)</div>
<div class="line">v.add(components.button(<span class="stringliteral">&quot;表示する文字列&quot;</span>, wcli.func(<span class="stringliteral">&quot;hoge&quot;</span>), id=<span class="stringliteral">&quot;button1&quot;</span>))</div>
</div><!-- fragment --> 関数を直接渡す場合 (WebUIや他MemberからはFuncの存在は見えません) <div class="fragment"><div class="line"><span class="keyword">def </span>hoge():</div>
<div class="line">    <span class="keywordflow">pass</span></div>
<div class="line">v.add(components.button(<span class="stringliteral">&quot;表示する文字列&quot;</span>, hoge, id=<span class="stringliteral">&quot;button1&quot;</span>));</div>
</div><!-- fragment --></li>
</ul>
</div><div class="tabbed"></div><h2><a class="anchor" id="autotoc_md99"></a>
input</h2>
<dl class="section since"><dt>Since</dt><dd><span class="since-c">1.10</span><span class="since-js">1.6</span><span class="since-py">2.0</span></dd></dl>
<p>viewに入力欄を表示します。</p>
<ul>
<li>textInput: 文字列入力</li>
<li>decimalInput: 小数入力</li>
<li>numberInput: 整数の入力</li>
<li>selectInput: リストから値を選択させる</li>
<li>toggleInput: クリックするたびに値が切り替わる</li>
<li>sliderInput: 数値を指定するスライダー</li>
<li>checkInput: チェックボックス</li>
</ul>
<h3><a class="anchor" id="autotoc_md100"></a>
InputRef</h3>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><p class="startli"><b class="tab-title">C++</b> 入力された値にアクセスするため <a class="el" href="classwebcface_1_1InputRef.html" title="名前を指定しないText">webcface::InputRef</a> オブジェクトを作成し、inputにbindします。 そのInputRefオブジェクトをコピーまたは参照で別の関数などに渡すと、あとから値を取得することができます。 </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_class" href="classwebcface_1_1InputRef.html">webcface::InputRef</a> input_val;</div>
<div class="line">v &lt;&lt; <a class="code hl_enumvalue" href="namespacewebcface.html#a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18">webcface::button</a>(<span class="stringliteral">&quot;cout &quot;</span>,</div>
<div class="line">                      [=] { std::cout &lt;&lt; input_val &lt;&lt; std::endl; })</div>
<div class="line">    .<span class="keywordtype">id</span>(<span class="stringliteral">&quot;button1&quot;</span>)</div>
<div class="line">  &lt;&lt; <a class="code hl_function" href="namespacewebcface_1_1components.html#aeea393bc3ef7353444b8a71552ad404f">webcface::textInput</a>(<span class="stringliteral">&quot;表示する文字列&quot;</span>).<a class="code hl_function" href="classwebcface_1_1TemporalViewComponent.html#a7fe27f33a23d228ef1a701ba30cc6cbb">bind</a>(input_val).<a class="code hl_function" href="classwebcface_1_1TemporalViewComponent.html#a15ad27cc4c91db0504f3e788b2596709">id</a>(<span class="stringliteral">&quot;input1&quot;</span>)</div>
<div class="line">  &lt;&lt; std::endl;</div>
<div class="ttc" id="aclasswebcface_1_1InputRef_html"><div class="ttname"><a href="classwebcface_1_1InputRef.html">webcface::InputRef</a></div><div class="ttdoc">名前を指定しないText</div><div class="ttdef"><b>Definition</b> text.h:439</div></div>
<div class="ttc" id="aclasswebcface_1_1TemporalViewComponent_html_a15ad27cc4c91db0504f3e788b2596709"><div class="ttname"><a href="classwebcface_1_1TemporalViewComponent.html#a15ad27cc4c91db0504f3e788b2596709">webcface::TemporalViewComponent::id</a></div><div class="ttdeci">TemporalViewComponent &amp; id(std::string_view id)</div><div class="ttdoc">idを設定</div><div class="ttdef"><b>Definition</b> component_view.cc:250</div></div>
<div class="ttc" id="aclasswebcface_1_1TemporalViewComponent_html_a7fe27f33a23d228ef1a701ba30cc6cbb"><div class="ttname"><a href="classwebcface_1_1TemporalViewComponent.html#a7fe27f33a23d228ef1a701ba30cc6cbb">webcface::TemporalViewComponent::bind</a></div><div class="ttdeci">TemporalViewComponent &amp; bind(const InputRef &amp;ref) &amp;</div><div class="ttdoc">変更した値を格納するInputRefを設定</div><div class="ttdef"><b>Definition</b> component_view.cc:302</div></div>
<div class="ttc" id="anamespacewebcface_1_1components_html_aeea393bc3ef7353444b8a71552ad404f"><div class="ttname"><a href="namespacewebcface_1_1components.html#aeea393bc3ef7353444b8a71552ad404f">webcface::components::textInput</a></div><div class="ttdeci">TemporalViewComponent textInput(std::string_view text=&quot;&quot;)</div><div class="ttdef"><b>Definition</b> components.h:631</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>上の例ではinput_valをstatic変数にし寿命が切れないようにしていますが、 staticにできない場合(複数のviewで使い回す場合など)は次の例のようにviewの生成ごとにInputRefオブジェクトを生成・破棄しても動作はします。 <div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>){</div>
<div class="line">    <span class="keyword">auto</span> v = wcli.<a class="code hl_function" href="structwebcface_1_1Field.html#a1a6e1affea60ef37fbb3118637671da0">view</a>(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="classwebcface_1_1InputRef.html">webcface::InputRef</a> input_val;</div>
<div class="line">    v &lt;&lt; <a class="code hl_enumvalue" href="namespacewebcface.html#a11040d82967b60182816ddc035d07c28ace50a09343724eb82df11390e2c1de18">webcface::button</a>(<span class="stringliteral">&quot;cout &quot;</span>,</div>
<div class="line">                          [=] { std::cout &lt;&lt; input_val &lt;&lt; std::endl; })</div>
<div class="line">        .<span class="keywordtype">id</span>(<span class="stringliteral">&quot;button1&quot;</span>)</div>
<div class="line">      &lt;&lt; <a class="code hl_function" href="namespacewebcface_1_1components.html#aeea393bc3ef7353444b8a71552ad404f">webcface::textInput</a>(<span class="stringliteral">&quot;表示する文字列&quot;</span>).<a class="code hl_function" href="classwebcface_1_1TemporalViewComponent.html#a7fe27f33a23d228ef1a701ba30cc6cbb">bind</a>(input_val).<a class="code hl_function" href="classwebcface_1_1TemporalViewComponent.html#a15ad27cc4c91db0504f3e788b2596709">id</a>(<span class="stringliteral">&quot;input1&quot;</span>)</div>
<div class="line">      &lt;&lt; std::endl;</div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;input_val = &quot; &lt;&lt; input_val.get(); この場合ここでは使えない</span></div>
<div class="line">    v.<a class="code hl_function" href="classwebcface_1_1View.html#a504472014f457652159a49ff8fa1429a">sync</a>();</div>
<div class="line">    wcli.<a class="code hl_function" href="classwebcface_1_1View.html#a504472014f457652159a49ff8fa1429a">sync</a>();</div>
<div class="line">}</div>
</div><!-- fragment --> この場合はv.sync()の時に前周期のinput_valの内容が復元されるという挙動になります。 (したがってv.sync()より前では値が未初期化になります)</dd></dl>
<p><span class="since-c">1.11</span> InputRefの値は <code>asStringRef()</code>, <code>asString()</code>, <code>asBool()</code>, <del><code>as&lt;double&gt;()</code></del> で型を指定して取得できます。 <br  />
 <span class="since-c">2.0</span> <code>asWStringRef()</code>, <code>asWString()</code>, <code>asDouble()</code>, <code>asInt()</code>, <code>asLLong()</code> も使えます。 <br  />
 (std::string, double, bool などの型にキャストすることでも値を得られます。) <br  />
 (任意の型に対応したい場合は <code>get()</code> で <a class="el" href="classwebcface_1_1ValAdaptor.html" title="数値、文字列などの値を相互変換するクラス">webcface::ValAdaptor</a> 型として取得できます。)</p>
<dl class="section note"><dt>Note</dt><dd>内部の実装では入力値を受け取りInputRefに値をセットする関数をonChangeにセットしています。 また、InputRefの値は<a class="el" href="md_docs_252__text.html">Text</a>型のデータとしてviewを表示しているクライアントに送信されます。</dd></dl>
<p><span></span></p>
</li>
<li><b class="tab-title">JavaScript</b> 入力された値にアクセスするため <a href="https://na-trium-144.github.io/webcface-js/classes/InputRef.html">InputRef</a> オブジェクトを作成し、inputにbindします。 そのInputRefオブジェクトを別の関数などに渡すと、あとから値を取得することができます。 <div class="fragment"><div class="line">import { InputRef, viewComponents } from &quot;webcface&quot;;</div>
<div class="line">const inputVal = new InputRef();</div>
<div class="line">setInterval(() =&gt; {</div>
<div class="line">    wcli.view(&quot;hoge&quot;).set([</div>
<div class="line">        viewComponents.button(&quot;cout&quot;, () =&gt; console.log(inputVal.get())),</div>
<div class="line">        viewComponents.textInput(&quot;表示する文字列&quot;, { bind: inputVal }),</div>
<div class="line">    ]);</div>
<div class="line">    wcli.sync();</div>
<div class="line">}, 100);</div>
</div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>viewを繰り返し送信するときInputRefオブジェクトは同じものを使いまわすのでも、 毎回新しいInputRefオブジェクトを生成するのでも、どちらでも動作します。 <div class="fragment"><div class="line"><span class="keyword">import</span> { <a class="code hl_class" href="classwebcface_1_1InputRef.html">InputRef</a>, viewComponents } from <span class="stringliteral">&quot;webcface&quot;</span>;</div>
<div class="line">setInterval(() =&gt; {</div>
<div class="line">    <span class="keyword">const</span> inputVal = <span class="keyword">new</span> <a class="code hl_class" href="classwebcface_1_1InputRef.html">InputRef</a>(); <span class="comment">// 毎回新しいInputRef</span></div>
<div class="line">    wcli.view(<span class="stringliteral">&quot;hoge&quot;</span>).set([</div>
<div class="line">        viewComponents.button(<span class="stringliteral">&quot;cout&quot;</span>, () =&gt; console.log(inputVal.get())), <span class="comment">// ok</span></div>
<div class="line">        viewComponents.textInput(<span class="stringliteral">&quot;表示する文字列&quot;</span>, { bind: inputVal }),</div>
<div class="line">        <span class="comment">// inputVal.get(), // ここでは使えない</span></div>
<div class="line">    ]);</div>
<div class="line">    wcli.sync();</div>
<div class="line">}, 100);</div>
</div><!-- fragment --> この場合はview.set()が実行される時に前周期のinputValの内容が復元されるという挙動になります。 (したがってv.set()の引数内ではinputValの値は未初期化になります)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>内部の実装では入力値を受け取りInputRefに値をセットする関数をonChangeにセットしています。 また、InputRefの値は<a class="el" href="md_docs_252__text.html">Text</a>型のデータとしてviewを表示しているクライアントに送信されます。</dd></dl>
<span></span></li>
<li><p class="startli"><b class="tab-title">Python</b> 入力された値にアクセスするため InputRef オブジェクトを作成し、inputにbindします。 そのInputRefオブジェクトをコピーまたは参照で別の関数などに渡すと、あとから値を取得することができます。 </p><div class="fragment"><div class="line"><span class="keyword">from</span> webcface <span class="keyword">import</span> InputRef</div>
<div class="line">input_val = InputRef()</div>
<div class="line"><span class="keyword">def </span>print_val():</div>
<div class="line">    print(str(input_val.get()))</div>
<div class="line">v.add(components.button(<span class="stringliteral">&quot;print&quot;</span>, print_val, id=<span class="stringliteral">&quot;button1&quot;</span>))</div>
<div class="line">v.add(components.text_input(<span class="stringliteral">&quot;表示する文字列&quot;</span>, bind=input_val, id=<span class="stringliteral">&quot;input1&quot;</span>)</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>viewを繰り返し送信するときInputRefオブジェクトは同じものを使いまわすのでも、 毎回新しいInputRefオブジェクトを生成するのでも、どちらでも動作します。 <div class="fragment"><div class="line"><span class="keyword">from</span> webcface <span class="keyword">import</span> InputRef</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">    input_val = InputRef()</div>
<div class="line">    <span class="keyword">def </span>print_val():</div>
<div class="line">        print(str(input_val.get()))</div>
<div class="line">    <span class="keyword">with</span> wcli.view(<span class="stringliteral">&quot;hoge&quot;</span>) <span class="keyword">as</span> v:</div>
<div class="line">        v.add(components.button(<span class="stringliteral">&quot;print&quot;</span>, print_val, id=<span class="stringliteral">&quot;button1&quot;</span>))</div>
<div class="line">        v.add(components.text_input(<span class="stringliteral">&quot;表示する文字列&quot;</span>, bind=input_val, id=<span class="stringliteral">&quot;input1&quot;</span>)</div>
<div class="line">        <span class="comment"># print(input_val.get()) # ここでは使えない</span></div>
<div class="line">        <span class="comment"># v.sync()</span></div>
<div class="line">    wcli.sync()</div>
</div><!-- fragment --> この場合はview.sync()が実行される時に前周期のinput_valの内容が復元されるという挙動になります。 (したがってv.sync()より前ではinput_valの値は未初期化になります)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>内部の実装では入力値を受け取りInputRefに値をセットする関数をonChangeにセットしています。 また、InputRefの値は<a class="el" href="md_docs_252__text.html">Text</a>型のデータとしてviewを表示しているクライアントに送信されます。</dd></dl>
<p><span></span></p>
</li>
</ul>
</div><div class="tabbed"></div><h3><a class="anchor" id="autotoc_md101"></a>
onChange</h3>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><p class="startli"><b class="tab-title">C++</b> onChange() で値が入力されたときに実行する関数を設定でき、こちらでも値が取得できます。 buttonに渡す関数と同様、関数オブジェクト、Funcオブジェクト、FuncListenerオブジェクトが使用できます。 </p><div class="fragment"><div class="line">v &lt;&lt; <a class="code hl_function" href="namespacewebcface_1_1components.html#aeea393bc3ef7353444b8a71552ad404f">webcface::textInput</a>(<span class="stringliteral">&quot;表示する文字列&quot;</span>).<a class="code hl_function" href="classwebcface_1_1TemporalViewComponent.html#a15ad27cc4c91db0504f3e788b2596709">id</a>(<span class="stringliteral">&quot;input1&quot;</span>).<a class="code hl_function" href="classwebcface_1_1TemporalViewComponent.html#a7003ea06e11e7b952d2e8be1f5a874a6">onChange</a>([](std::string val) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;input changed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="ttc" id="aclasswebcface_1_1TemporalViewComponent_html_a7003ea06e11e7b952d2e8be1f5a874a6"><div class="ttname"><a href="classwebcface_1_1TemporalViewComponent.html#a7003ea06e11e7b952d2e8be1f5a874a6">webcface::TemporalViewComponent::onChange</a></div><div class="ttdeci">TemporalViewComponent &amp; onChange(T func) &amp;</div><div class="ttdoc">値が変化した時に実行される関数を設定</div><div class="ttdef"><b>Definition</b> component_view.h:429</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>bindとonChangeを両方設定することはできません。</dd></dl>
<p><span></span></p>
</li>
<li><p class="startli"><b class="tab-title">JavaScript</b> onChange で値が入力されたときに実行する関数を設定でき、こちらでも値が取得できます。 buttonに渡す関数と同様、関数、Funcオブジェクトが使用できます。 </p><div class="fragment"><div class="line">viewComponents.textInput(&quot;表示する文字列&quot;, {</div>
<div class="line">    onChange: (val: string | number | boolean) =&gt; console.log(val),</div>
<div class="line">})</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>bindとonChangeを両方設定することはできません。</dd></dl>
<p><span></span></p>
</li>
<li><p class="startli"><b class="tab-title">Python</b> on_change で値が入力されたときに実行する関数を設定でき、こちらでも値が取得できます。 buttonに渡す関数と同様、関数、ラムダ式、またはFuncオブジェクト、FuncListenerオブジェクトが使用できます。 </p><div class="fragment"><div class="line">components.text_input(&quot;表示する文字列&quot;, id=&quot;input1&quot;, on_change=...)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>bindとonChangeを両方設定することはできません。</dd></dl>
<p><span></span></p>
</li>
</ul>
</div><div class="tabbed"></div><h2><a class="anchor" id="autotoc_md102"></a>
オプション</h2>
<p>各ViewComponentには以下のオプションを指定することができます。 (要素の種類によっては効果がないものもあります)</p>
<ul>
<li>textColor: 文字の色を変更します。<ul>
<li>WebUIではデフォルトは黒です</li>
</ul>
</li>
<li>bgColor: 背景色を変更します。<ul>
<li>WebUIではデフォルトは緑です</li>
</ul>
</li>
<li>各種inputに指定できるオプション (<a class="el" href="md_docs_253__func.html">Func</a>のArgオプションと同様です。)<ul>
<li>init: 初期値</li>
<li>min: 最小値, max: 最大値 (decimalInput, numberInput, sliderInputのみ)</li>
<li>min: 最小文字数, max: 最大文字数 (textInputのみ)</li>
<li>step: 刻み幅 (numberInput, sliderInputのみ)</li>
<li>option: 選択肢 (selectInput, toggleInput)</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="md_docs_275__tui.html">webcface-tui</a>では文字色と背景色に指定した白と黒がそれぞれ反転して表示されます。</dd></dl>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><p class="startli"><b class="tab-title">C++</b> <code>button(...).textColor(...)</code> などのようにメソッドチェーンすることで各要素にオプションを設定できます。 詳細は <a class="el" href="classwebcface_1_1TemporalViewComponent.html" title="Viewを構築するときに使う一時的なViewComponent.">webcface::TemporalViewComponent</a> のリファレンスを参照してください。</p>
<p class="startli">色は <a class="el" href="namespacewebcface.html#a5dcc1f15d6a60ca34207565aeb74124a">webcface::ViewColor</a> のenumで指定します。</p>
</li>
<li><p class="startli"><b class="tab-title">C</b> <a class="el" href="structwcfViewComponent.html" title="Viewの要素を表すstruct.">wcfViewComponent</a> 構造体のメンバーでオプションを指定することができます。</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structwcfViewComponent.html">wcfViewComponent</a> vc[10];</div>
<div class="line">vc[0] = <a class="code hl_function" href="client_2include_2webcface_2c__wcf_2view_8h.html#aa4da60375e4605b9c85fa1ded4d1c479">wcfText</a>(<span class="stringliteral">&quot;hello world\n&quot;</span>);</div>
<div class="line">vc[0].text_color = <a class="code hl_enumvalue" href="def__types_8h.html#ad8149f97b37c9ddd8216f78fc722dfd7a2e09ecac55fdd6438a0b591822d8d262">WCF_COLOR_RED</a>;</div>
<div class="ttc" id="adef__types_8h_html_ad8149f97b37c9ddd8216f78fc722dfd7a2e09ecac55fdd6438a0b591822d8d262"><div class="ttname"><a href="def__types_8h.html#ad8149f97b37c9ddd8216f78fc722dfd7a2e09ecac55fdd6438a0b591822d8d262">WCF_COLOR_RED</a></div><div class="ttdeci">@ WCF_COLOR_RED</div><div class="ttdef"><b>Definition</b> def_types.h:200</div></div>
</div><!-- fragment --></li>
<li><b class="tab-title">JavaScript</b> <code>button("text", { textColor: ... })</code> などのように、オプションはそれぞれ関数の引数にオブジェクトで渡すことができます。</li>
<li><p class="startli"><b class="tab-title">Python</b> <code>button("text", text_color=...)</code> などのように、それぞれ関数のキーワード引数でオプションを設定できます。</p>
<p class="startli"><span class="since-c">3.0</span> add() の引数にキーワード引数を追加しても同様に要素にオプションが追加されます。</p>
</li>
</ul>
</div><div class="tabbed"></div><h1><a class="anchor" id="autotoc_md103"></a>
受信</h1>
<p>ViewデータはWebUIに表示するだけでなく、ValueやTextと同様プログラムから受信することもできます。 (これを使うのはViewを表示するアプリを作る場合などですかね)</p>
<div class="tabbed"></div><div class="tabbed"><ul>
<li><p class="startli"><b class="tab-title">C++</b> Member::view() でViewクラスのオブジェクトが得られ、 View::tryGet(), View::get() で受信したViewデータを取得できます。</p>
<p class="startli">Viewデータは <a class="el" href="classwebcface_1_1ViewComponent.html" title="Viewに表示する要素です">webcface::ViewComponent</a> のリストとして得られ、 ViewComponentオブジェクトから各種プロパティを取得できます。</p>
<p class="startli">例えば<code>foo</code>というクライアントの<code>hoge</code>という名前のデータを取得したい場合は次のようにします。</p>
<div class="fragment"><div class="line">std::optional&lt;std::vector&lt;ViewComponent&gt;&gt; hoge = wcli.member(<span class="stringliteral">&quot;foo&quot;</span>).view(<span class="stringliteral">&quot;hoge&quot;</span>).tryGet();</div>
</div><!-- fragment --><ul>
<li>値をまだ受信していない場合 tryGet() はstd::nulloptを返し、そのデータのリクエストをサーバーに送ります。<ul>
<li>リクエストは <del>次にClient::sync()したときに</del> <span class="since-c">1.2</span>自動的に別スレッドで送信されます。</li>
<li>そのデータを受信した後(<a class="el" href="md_docs_241__client.html">4-1. Client</a>を参照)、再度tryGet()することで値が得られます。</li>
</ul>
</li>
<li>View::get() はstd::nulloptの代わりに空のvectorを返します。</li>
</ul>
<p class="startli"><span class="since-c">1.7</span> View::request() で明示的にリクエストを送信することもできます。</p>
</li>
<li><p class="startli"><b class="tab-title">C</b> </p><dl class="section since"><dt>Since</dt><dd><span class="since-c">1.7</span></dd></dl>
<p>wcfViewGet, (<span class="since-c">2.0</span> wcfViewGetW) で <a class="el" href="structwcfViewComponent.html" title="Viewの要素を表すstruct.">wcfViewComponent</a>, (<span class="since-c">2.0</span> <a class="el" href="structwcfViewComponentW.html" title="Viewの要素を表すstruct (wstring)">wcfViewComponentW</a>) の配列が得られます。</p>
<p class="startli">取得した配列は不要になったら wcfDestroy で破棄してください。</p>
</li>
<li><p class="startli"><b class="tab-title">JavaScript</b> Member.view() でViewクラスのオブジェクトが得られ、 View.tryGet(), View.get() で受信したViewデータを取得できます。</p>
<p class="startli">Viewデータは <a href="https://na-trium-144.github.io/webcface-js/classes/ViewComponent.html">ViewComponent</a> のリストとして得られ、 ViewComponentオブジェクトから各種プロパティを取得できます。</p>
<p class="startli">例えば<code>foo</code>というクライアントの<code>hoge</code>という名前のデータを取得したい場合は次のようにします。</p>
<div class="fragment"><div class="line">const hoge: ViewComponent[] | null = wcli.member(&quot;foo&quot;).view(&quot;hoge&quot;).tryGet();</div>
</div><!-- fragment --><ul>
<li>値を受信していない場合 tryGet() はnullを返し、そのデータのリクエストをサーバーに送ります。<ul>
<li>リクエストは <del>次にClient.sync()したときに</del> <span class="since-js">1.1</span>自動的に別スレッドで送信されます。</li>
<li>そのデータを受信した後(<a class="el" href="md_docs_241__client.html">4-1. Client</a>を参照)、再度tryGet()することで値が得られます。</li>
</ul>
</li>
<li>get() はnullの代わりに空のリストを返します。</li>
</ul>
<p class="startli"><span class="since-js">1.1</span> View.request()で明示的にリクエストを送信することもできます。</p>
</li>
<li><p class="startli"><b class="tab-title">Python</b> Member.view() でViewクラスのオブジェクトが得られ、 View.tryGet(), View.get() で受信したViewデータを取得できます。</p>
<p class="startli">Viewデータは <a href="https://na-trium-144.github.io/webcface-python/webcface.view.html#webcface.view.ViewComponent">webcface.ViewComponent</a> のリストとして得られ、 ViewComponentオブジェクトから各種プロパティを取得できます。</p>
<p class="startli">例えば<code>foo</code>というクライアントの<code>hoge</code>という名前のデータを取得したい場合は次のようにします。</p>
<div class="fragment"><div class="line">hoge = wcli.member(<span class="stringliteral">&quot;foo&quot;</span>).view(<span class="stringliteral">&quot;hoge&quot;</span>).try_get()</div>
</div><!-- fragment --><ul>
<li>値を受信していない場合 try_get() はNoneを返し、そのデータのリクエストをサーバーに送ります。<ul>
<li>そのデータを受信した後(<a class="el" href="md_docs_241__client.html">4-1. Client</a>を参照)、再度try_get()することで値が得られます。</li>
</ul>
</li>
<li>get() はNoneの代わりに空のリストを返します。</li>
</ul>
<p class="startli">View.request()で明示的にリクエストを送信することもできます。</p>
</li>
</ul>
</div><div class="tabbed"></div><h2><a class="anchor" id="autotoc_md104"></a>
onClick</h2>
<p>ViewComponent::onClick() でボタン要素のクリック時に実行するべき関数が<a class="el" href="md_docs_253__func.html">Func</a>オブジェクトとして取得できます。 したがって、ボタンを表示し、クリックされたときに<code>onClick().runAsync()</code>などとすることでそのボタンを動作させられます。</p>
<h2><a class="anchor" id="autotoc_md105"></a>
onChangeとbind</h2>
<p><span class="since-c">1.10</span> <span class="since-js">1.6</span> <span class="since-py">2.0</span></p>
<p>各種Input要素の現在の値は ViewComponent::bind() で <del><a class="el" href="md_docs_252__text.html">Text</a>オブジェクトとして</del> <span class="since-c">2.0</span> <span class="since-py">2.0</span> Variant オブジェクトとして取得できます。 したがって<code>bind()</code>の値をInputの初期値として使用すればよいです。</p>
<p>Inputの値を変更する際は、(view送信側がbindを設定したかonChangeを設定したかに関わらず) ViewComponent::onChange() を使います。 引数に変化後の値を渡して<code>onChange().runAsync("変化後の値")</code>などとすることで onChangeに設定された関数を実行すると同時にbindの値も変更されます。</p>
<h2><a class="anchor" id="autotoc_md106"></a>
id</h2>
<p><span class="since-c">1.10</span> <span class="since-js">1.6</span> <span class="since-py">3.0</span></p>
<p>ViewComponent::id() で各要素に割り振られたid(文字列)を取得できます。 このidはそのview内で一意で、(buttonやInputの総数や順序が変わらなければ) 同じbutton、同じinputには常に同じidが振られます。</p>
<h2><a class="anchor" id="autotoc_md107"></a>
時刻</h2>
<p><strike>View::time()</strike> でその値が送信されたとき(そのMemberがsync()したとき)の時刻が得られます。 <br  />
 <span class="since-c">1.7</span> <span class="since-js">1.6</span> <span class="since-py"></span> Member::syncTime() に統一しました。詳細は <a class="el" href="md_docs_251__value.html">5-1. Value</a> を参照</p>
<h2><a class="anchor" id="autotoc_md108"></a>
Entry</h2>
<p>Valueと同様、データ自体を受信しなくてもデータが存在するかどうかは取得することができます。 使い方は <a class="el" href="md_docs_251__value.html">Value</a> と同様なのでそちらを参照してください</p>
<h2><a class="anchor" id="autotoc_md109"></a>
Event</h2>
<p>受信したデータが変化したときにコールバックを呼び出すことができます。 コールバックを設定することでもその値はリクエストされます。</p>
<p>また、データが変化したどうかに関わらずそのMemberがsync()したときにコールバックを呼び出したい場合は Member::onSync() が使えます</p>
<p>使い方は <a class="el" href="md_docs_251__value.html">Value</a> と同様なのでそちらを参照してください</p>
<div class="section_buttons"></div><div class="section_buttons"><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Previous   </th><th class="markdownTableHeadRight">Next    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="md_docs_253__func.html">5-3. Func</a>   </td><td class="markdownTableBodyRight"><a class="el" href="md_docs_255__log.html">5-5. Log</a>   </td></tr>
</table>
</div><div class="section_buttons"></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jan 2 2025 04:54:53 for WebCFace by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
